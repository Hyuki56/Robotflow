<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/5.10.4/mqtt.min.js"></script>
  <title>Object Test</title>
  <style>
    .seat-grid {
      display: grid;
      grid-template-columns: repeat(4, 80px); /* 4ì—´ */
      grid-template-rows: repeat(3, 80px);    /* 3í–‰ */
      gap: 10px;
      justify-content: center;
      margin-top: 30px;
    }

    .seat {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #eee;ã…ˆ
      border: 2px solid #333;
      font-weight: bold;
      font-size: 16px;
      width: 80px;
      height: 80px;
      box-sizing: border-box;
    }

    .seat.empty {
      background-color: green;
    }
    .seat.used {
      background-color: red;
    }
    .seat.unknown {
      background-color: #eee;
    }
    .seat.reserved {
      background-color: yellow;
    }

  </style>
</head>
<body>
<h1>ê°ì²´ ì •ë³´ í˜ì´ì§€</h1>
<a href="/"> í™ˆí˜ì´ì§€ </a>

<!-- ì¢Œì„í‘œ (3í–‰ x 4ì—´) -->
<div class="seat-grid">
  <div class="seat" id="seat-0-0">A1</div>
  <div class="seat" id="seat-0-1">A2</div>
  <div class="seat" id="seat-0-2">A3</div>
  <div class="seat" id="seat-0-3">A4</div>

  <div class="seat" id="seat-1-0">B1</div>
  <div class="seat" id="seat-1-1">B2</div>
  <div class="seat" id="seat-1-2">B3</div>
  <div class="seat" id="seat-1-3">B4</div>

  <div class="seat" id="seat-2-0">C1</div>
  <div class="seat" id="seat-2-1">C2</div>
  <div class="seat" id="seat-2-2">C3</div>
  <div class="seat" id="seat-2-3">C4</div>
</div>

<img id="frontImage" style="max-width: 400px; display: none;">
<img id="backImage" style="max-width: 400px; display: none;">


<script type="text/javascript">
  const client = mqtt.connect('ws://localhost:9001');
  let Objects = null;
  let frontPrintDone = false; // ë¡œê·¸ ì²« ì¶œë ¥ ì—¬ë¶€
  let backPrintDone = false; // ë¡œê·¸ ì²« ì¶œë ¥ ì—¬ë¶€
  let frontImageDisplayed = true;
  let backImageDisplayed = true;

  client.on("connect", () => {
    console.log("Connected");
    client.subscribe('/camera/front');
    client.subscribe('/camera/back');
  });

  client.on("message", (topic, message) => {
    try {
      const { objects, image } = JSON.parse(message.toString());
      Objects = objects;

      // ì²˜ìŒ ìˆ˜ì‹ í–ˆì„ ë•Œë§Œ í•œ ë²ˆ ì¶œë ¥
      if (topic === '/camera/front' && !frontPrintDone && Objects) {
        printObjects(topic);
        frontPrintDone = true;
      }

      if (topic === '/camera/back' && !backPrintDone && Objects) {
        printObjects(topic);
        backPrintDone = true;
      }

      // ìµœì´ˆ 1íšŒë§Œ ì´ë¯¸ì§€ ì¶œë ¥
      if (topic === '/camera/front' && !frontImageDisplayed && image) {
        const img = document.getElementById("frontImage");
        img.src = `data:image/jpg;base64,${image}`;
        img.style.display = 'block';
        frontImageDisplayed = true;
      }

      if (topic === '/camera/back' && !backImageDisplayed && image) {
        const img = document.getElementById("backImage");
        img.src = `data:image/jpg;base64,${image}`;
        img.style.display = 'block';
        backImageDisplayed = true;
      }

    } catch (e) {
      console.error("Parse error:", e);
    }
  });

  let filteredFrontObjects = [];
  let filteredBackObjects = [];

  let frontSeatMap = [];
  let backSeatMap = [];

  function getDistance(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
  }

  function printObjects(topic) {

    if (topic === '/camera/front'){
      console.log(`[${topic}]`, Objects);

      if (Objects) {
        console.log("Detected Front Objects :", Objects);
        Objects.forEach((obj, i) => {
          const [x1, y1, x2, y2] = obj.box;
          const confidence = obj.confidence;

          let found = false;

          for (let i = 0; i < filteredFrontObjects.length; i++) {
            const existing = filteredFrontObjects[i];
            const [exX1, exY1, exX2, exY2] = existing.box;

            const dist1 = getDistance(x1, y1, exX1, exY1);
            const dist2 = getDistance(x2, y2, exX2, exY2);

            if (dist1 <= 20 || dist2 <= 20) {
              found = true;

              // used ë¥¼ ìš°ì„ ì‹œí•˜ëŠ” ì½”ë“œ

              const isNewUsed = obj.label === 'used';
              const isExistingUsed = existing.label === 'used';

              if (isNewUsed && !isExistingUsed) {
                filteredFrontObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, label=used (priority over null)`);
              } else if (!isNewUsed && isExistingUsed) {
                console.log(`(skipped) box=${obj.box}, label=null < existing used`);
              } else if (confidence > existing.confidence) {
                filteredFrontObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, confidence=${obj.confidence}`);
              } else {
                console.log(`(skipped) box=${obj.box}, lower confidence`);
              }

              // confidence ë§Œìœ¼ë¡œ ë¹„êµí•˜ëŠ” ì½”ë“œ

              // if (confidence > existing.confidence) {
              //     filteredObjects[i] = obj;
              //     console.log(`(updated) box=${obj.box}, confidence=${confidence}`);
              // } else {
              //     console.log(`(skipped) box=${obj.box}, lower confidence`);
              // }


              break;
            }

          }

          if (!found) {
            filteredFrontObjects.push(obj);
            console.log(`(new) box=${obj.box}, confidence=${obj.confidence}`);
          }
        });
      }
      // ì •ë ¬: ì•ì¤„ë¶€í„°, ì¢Œì¸¡ë¶€í„°
      // 1. y1 ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë¨¼ì € ì „ì²´ ì •ë ¬
      filteredFrontObjects.sort((a, b) => a.box[1] - b.box[1]);

      console.log("filtered Front Objects: ", filteredFrontObjects)

// 2. y1 ì°¨ì´ë¡œ ê·¸ë£¹í•‘ (ìˆœì„œëŠ” ëª¨ë‹ˆí„°í™”ë©´ì´ ë³´ì´ëŠ” ì •ë°©í–¥ ê¸°ì¤€)
      let rows = [];

// ì²« ë²ˆì§¸ í–‰ (y1 >= 221)
      let row1 = filteredFrontObjects.filter(obj => obj.box[1] > 220);
      if (row1.length > 0) rows.push(row1);

// ë‘ ë²ˆì§¸ í–‰ (141 <= y1 <= 220)
      let row2 = filteredFrontObjects.filter(obj => obj.box[1] > 140 && obj.box[1] <= 220);
      if (row2.length > 0) rows.push(row2);

// ì„¸ ë²ˆì§¸ í–‰ (y1 <= 140)
      let row3 = filteredFrontObjects.filter(obj => obj.box[1] <= 140);
      if (row3.length > 0) rows.push(row3);



// 3. ê° í–‰ì—ì„œ x1 ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
      rows.forEach(row => {
        row.sort((a, b) => a.box[0] - b.box[0]);
      });


      const seatLabels = [
        // Cí–‰
        ['C4', 'C3', 'C2', 'C1'],
        // Bí–‰
        ['B4', 'B3', 'B2', 'B1'],
        // Cí–‰
        ['A4', 'A3', 'A2', 'A1']
      ];

      seatLabels.reverse().forEach((row, i) => {
        seatLabels[i] = row.reverse();
      });


// ê° í–‰ì— ëŒ€í•œ x1 ë²”ìœ„
      const xRangesPerRow = [
        [ [100, 200], [250, 350], [400, 500], [500, 600] ], // A
        [ [100, 200], [300, 400], [500, 600], [600, 700] ], // B
        [ [200, 300], [500, 600], [700, 800], [900, 1000] ]  // C
      ];

      xRangesPerRow.reverse().forEach((row, i) => {
        xRangesPerRow[i] = row.reverse();
      });


// ì¢Œì„ ë§¤í•‘ ê²°ê³¼ ì €ì¥ìš©

      rows.forEach((row, rowIndex) => {
        const rowRanges = xRangesPerRow[rowIndex];
        const rowSeats = Array(4).fill(null); // ì¢Œì„ 4ê°œ

        row.forEach(obj => {
          const x1 = obj.box[0];
          // í•´ë‹¹ í–‰ì˜ ì¢Œì„ ë²”ìœ„ì— ë”°ë¼ ì¢Œì„ ìœ„ì¹˜ ì°¾ê¸°
          for (let i = 0; i < rowRanges.length; i++) {
            const [min, max] = rowRanges[i];
            if (x1 >= min && x1 <= max && !rowSeats[i]) {
              rowSeats[i] = { label: seatLabels[rowIndex][i], ...obj };

              break;
            }
          }
        });

        frontSeatMap.push(rowSeats);
      });

      console.log("frontSeatMap: ", frontSeatMap);

    }


    if (topic === '/camera/back'){
      console.log(`[${topic}]`, Objects);

      if (Objects) {
        console.log("Detected Back Objects:", Objects);
        Objects.forEach((obj, i) => {
          const [x1, y1, x2, y2] = obj.box;
          const confidence = obj.confidence;

          // x1 ê°’ì´ 1200 ì´ìƒì´ë©´ ë¬´ì‹œ
          if (x1 >= 1200) {
            console.log(`(ignored) box=${obj.box}, x1 >= 1200`);
            return;
          }

          let found = false;

          for (let i = 0; i < filteredBackObjects.length; i++) {
            const existing = filteredBackObjects[i];
            const [exX1, exY1, exX2, exY2] = existing.box;

            const dist1 = getDistance(x1, y1, exX1, exY1);
            const dist2 = getDistance(x2, y2, exX2, exY2);

            if (dist1 <= 20 || dist2 <= 20) {
              found = true;

              const isNewUsed = obj.label === 'used';
              const isExistingUsed = existing.label === 'used';

              if (isNewUsed && !isExistingUsed) {
                filteredBackObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, label=used (priority over null)`);
              } else if (!isNewUsed && isExistingUsed) {
                console.log(`(skipped) box=${obj.box}, label=null < existing used`);
              } else if (confidence > existing.confidence) {
                filteredBackObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, confidence=${obj.confidence}`);
              } else {
                console.log(`(skipped) box=${obj.box}, lower confidence`);
              }

              break;
            }

          }

          if (!found) {
            filteredBackObjects.push(obj);
            console.log(`(new) box=${obj.box}, confidence=${obj.confidence}`);
          }
        });
      }
      // ì •ë ¬: ì•ì¤„ë¶€í„°, ì¢Œì¸¡ë¶€í„°
      // 1. y1 ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë¨¼ì € ì „ì²´ ì •ë ¬
      filteredBackObjects.sort((a, b) => a.box[1] - b.box[1]);

      console.log("filtered Back Objects: " , filteredBackObjects)

// 2. y1 ë²”ìœ„ë¡œ ê·¸ë£¹í•‘
      let rows = [];

// ì²« ë²ˆì§¸ í–‰ (200 <= y1 < 260)
      let row1 = filteredBackObjects.filter(obj => obj.box[1] >= 200 && obj.box[1] < 260);
      if (row1.length > 0) rows.push(row1);

// ë‘ ë²ˆì§¸ í–‰ (260 <= y1 < 380)
      let row2 = filteredBackObjects.filter(obj => obj.box[1] >= 260 && obj.box[1] < 380);
      if (row2.length > 0) rows.push(row2);

// ì„¸ ë²ˆì§¸ í–‰ (380 <= y1)
      let row3 = filteredBackObjects.filter(obj => obj.box[1] >= 380);
      if (row3.length > 0) rows.push(row3);

// 3. ê° í–‰ì—ì„œ x1 ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
      rows.forEach(row => {
        row.sort((a, b) => a.box[0] - b.box[0]);
      });

      console.log("rows: ", rows)


      const seatLabels = [
        // Aí–‰
        ['A1', 'A2', 'A3', 'A4'],
        // Bí–‰
        ['B1', 'B2', 'B3', 'B4'],
        // Cí–‰
        ['C1', 'C2', 'C3', 'C4']
      ];

// ê° í–‰ì— ëŒ€í•œ x1 ë²”ìœ„
      const xRangesPerRow = [
        [ [500, 600], [650, 750], [800, 900], [950, 1050] ], // A
        [ [250, 350], [550, 650], [750, 850], [950, 1050] ], // B
        [ [0, 100],   [300, 400], [650, 750], [1000, 1100] ]  // C
      ];

// ì¢Œì„ ë§¤í•‘ ê²°ê³¼ ì €ì¥ìš©

      rows.forEach((row, rowIndex) => {
        const rowRanges = xRangesPerRow[rowIndex];
        const rowSeats = Array(4).fill(null); // ì¢Œì„ 4ê°œ

        row.forEach(obj => {
          const x1 = obj.box[0];
          // í•´ë‹¹ í–‰ì˜ ì¢Œì„ ë²”ìœ„ì— ë”°ë¼ ì¢Œì„ ìœ„ì¹˜ ì°¾ê¸°
          for (let i = 0; i < rowRanges.length; i++) {
            const [min, max] = rowRanges[i];
            if (x1 >= min && x1 <= max && !rowSeats[i]) {
              rowSeats[i] = { label: seatLabels[rowIndex][i], ...obj };
              break;
            }
          }
        });

        backSeatMap.push(rowSeats);
      });

      console.log("backSeatMap:", backSeatMap);

    }

    function getLabelPriority(label) {
      if (label === 'used') return 2;
      if (label) return 1; // ë¹„ì‹ë³„(labelì€ ì¡´ì¬í•˜ë˜ usedê°€ ì•„ë‹Œ ê²½ìš°)
      return 0; // null ë˜ëŠ” undefined
    }

    function mergeSeatMaps(frontSeatMap, backSeatMap) {
      const mergedSeatMap = [];

      for (let row = 0; row < 3; row++) {
        const mergedRow = [];

        for (let col = 0; col < 4; col++) {
          const frontSeat = frontSeatMap?.[row]?.[col] || null;
          const backSeat = backSeatMap?.[row]?.[col] || null;

          if (frontSeat && !backSeat) {
            mergedRow.push(frontSeat);
          } else if (!frontSeat && backSeat) {
            mergedRow.push(backSeat);
          } else if (frontSeat && backSeat) {
            const frontPriority = getLabelPriority(frontSeat.label);
            const backPriority = getLabelPriority(backSeat.label);

            if (frontPriority > backPriority) {
              mergedRow.push(frontSeat);
            } else if (backPriority > frontPriority) {
              mergedRow.push(backSeat);
            } else {
              // ê°™ì€ ìš°ì„ ìˆœìœ„ë©´ confidence ë¹„êµ
              mergedRow.push(
                      frontSeat.confidence >= backSeat.confidence ? frontSeat : backSeat
              );
            }
          } else {
            mergedRow.push(null);
          }
        }

        mergedSeatMap.push(mergedRow);
      }

      return mergedSeatMap;
    }

    async function setupSeats() {
      const mergeSeatMap = mergeSeatMaps(frontSeatMap, backSeatMap);
      console.log("Merged Seat Map:", mergeSeatMap);

      try {
        const res = await fetch('/reserve');
        const data = await res.json();
        console.log("âœ… DBì—ì„œ ê°€ì ¸ì˜¨ ì˜ˆì•½ ì¢Œì„ ëª©ë¡:", data);

        // ì˜ˆì•½ ì¢Œì„ì„ mergeSeatMapì— ë°˜ì˜
        data.forEach(seat => {
          const seatName = seat.seatName;
          const rowChar = seatName[0]; // A, B, C...
          const colNum = parseInt(seatName.slice(1), 10); // 1, 2, 3...

          const rowIndex = rowChar.charCodeAt(0) - 'A'.charCodeAt(0); // 'A' -> 0
          const colIndex = colNum - 1;

          if (mergeSeatMap[rowIndex] && mergeSeatMap[rowIndex][colIndex]) {
            mergeSeatMap[rowIndex][colIndex].label = seat.approved ? 'used' : 'reserved';
          }
        });

        const finalSeatMap = mergeSeatMap;
        console.log("ğŸ§© ìµœì¢…ì‹œíŠ¸ë§µ", finalSeatMap);

        const seatLabels = [
          ['A1', 'A2', 'A3', 'A4'],
          ['B1', 'B2', 'B3', 'B4'],
          ['C1', 'C2', 'C3', 'C4']
        ];

        for (let row = 0; row < seatLabels.length; row++) {
          for (let col = 0; col < seatLabels[row].length; col++) {
            const seatId = `seat-${row}-${col}`;
            const seatDiv = document.getElementById(seatId);
            const seatInfo = finalSeatMap[row][col];

            seatDiv.classList.remove('empty', 'used', 'unknown', 'reserved');

            if (!seatInfo) {
              seatDiv.classList.add('unknown');
            } else if (seatInfo.label === 'used') {
              seatDiv.classList.add('used');
            } else if (seatInfo.label === 'null') {
              seatDiv.classList.add('empty');
            } else if (seatInfo.label === 'reserved') {
              seatDiv.classList.add('reserved');
            } else {
              seatDiv.classList.add('unknown');
            }
          }
        }

      } catch (err) {
        console.error("âŒ ì¢Œì„ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", err);
      }
    }

// í˜¸ì¶œ
    setupSeats();


  }

</script>



<script>
  document.querySelectorAll('.seat').forEach(seat => {
    seat.addEventListener('click', () => {
      const seatName = seat.textContent; // ë˜ëŠ” innerText
      // 'empty' í´ë˜ìŠ¤ê°€ ìˆì„ ë•Œë§Œ ë°˜ì‘
      if (seat.classList.contains('empty')) {
        if (confirm(`${seatName} ì¢Œì„ì„ ì˜ˆì•½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {

          // AJAXë¡œ ì„œë²„ì— ì˜ˆì•½ì •ë³´ ì „ì†¡
          fetch('/reserve', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ seatName })
          })
                  .then(res => res.json())
                  .then(data => {
                    if (data.success) {
                      alert("ì˜ˆì•½ ì„±ê³µ!");
                      seat.classList.remove('empty');
                      seat.classList.add('reserved');
                    } else {
                      alert("ì˜ˆì•½ ì‹¤íŒ¨: " + data.message);
                    }
                  });

        }
      }
    });
  });
</script>

</body>
</html>
