<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/5.10.4/mqtt.min.js"></script>
  <title>Object Test</title>
  <style>
    .seat-grid {
      display: grid;
      grid-template-columns: repeat(4, 80px); /* 4ì—´ */
      grid-template-rows: repeat(3, 80px);    /* 3í–‰ */
      gap: 10px;
      justify-content: center;
      margin-top: 30px;
    }

    .seat {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #eee;
      border: 2px solid #333;
      font-weight: bold;
      font-size: 16px;
      width: 80px;
      height: 80px;
      box-sizing: border-box;
    }

    .seat.empty {
      background-color: green;
    }
    .seat.used {
      background-color: red;
    }
    .seat.unknown {
      background-color: #eee;
    }
    .seat.reserved {
      background-color: yellow;
    }

  </style>
</head>
<body>
<h1>ê°ì²´ ì •ë³´ í˜ì´ì§€</h1>
<a href="/"> í™ˆí˜ì´ì§€ </a>
<a href="/info" sec:authorize="hasRole('ROLE_ADMIN')"> ì˜ˆì•½ì •ë³´ ë° ìŠ¹ì¸ì²˜ë¦¬ </a>

<!-- ì˜ˆì•½ ì •ë³´ í‘œì‹œ ì˜ì—­ -->
<div id="reservation-info">
  <h2>ì˜ˆì•½ ì •ë³´</h2>
  <p id="reserved-seat"></p>
  <p id="reservation-time"></p>
  <!-- ì˜ˆì•½ ì·¨ì†Œ ë²„íŠ¼ -->
  <button id="cancel-reservation" style="display:none;">ì˜ˆì•½ ì·¨ì†Œ</button>
</div>

<!-- ì¢Œì„í‘œ (3í–‰ x 4ì—´) -->
<div class="seat-grid">
  <div class="seat" id="seat-0-0">A1</div>
  <div class="seat" id="seat-0-1">A2</div>
  <div class="seat" id="seat-0-2">A3</div>
  <div class="seat" id="seat-0-3">A4</div>

  <div class="seat" id="seat-1-0">B1</div>
  <div class="seat" id="seat-1-1">B2</div>
  <div class="seat" id="seat-1-2">B3</div>
  <div class="seat" id="seat-1-3">B4</div>

  <div class="seat" id="seat-2-0">C1</div>
  <div class="seat" id="seat-2-1">C2</div>
  <div class="seat" id="seat-2-2">C3</div>
  <div class="seat" id="seat-2-3">C4</div>
</div>

<img id="frontImage" style="max-width: 400px; display: none;">
<img id="backImage" style="max-width: 400px; display: none;">


<script th:inline="javascript">
  const client = mqtt.connect('ws://localhost:9001');
  let Objects = null;
  let frontPrintDone = false; // ë¡œê·¸ ì²« ì¶œë ¥ ì—¬ë¶€
  let backPrintDone = false; // false ë¡œ í•´ì•¼ ì¡°ê±´ë¬¸ì— ì˜í•´ printobjects ë¡œ ê°ì²´íƒì§€ê²°ê³¼ë¥¼ ê°€ì§€ê³ ì˜´
  let frontImageDisplayed = true;
  let backImageDisplayed = true;

  client.on("connect", () => {
    console.log("Connected");
    client.subscribe('/camera/front');
    client.subscribe('/camera/back');
  });

  client.on("message", (topic, message) => {
    try {
      const { objects, image } = JSON.parse(message.toString());
      Objects = objects;

      // ì²˜ìŒ ìˆ˜ì‹ í–ˆì„ ë•Œë§Œ í•œ ë²ˆ ì¶œë ¥
      if (topic === '/camera/front' && !frontPrintDone && Objects) {
        printObjects(topic);
        frontPrintDone = true;
      }

      if (topic === '/camera/back' && !backPrintDone && Objects) {
        printObjects(topic);
        backPrintDone = true;
      }

      // ìµœì´ˆ 1íšŒë§Œ ì´ë¯¸ì§€ ì¶œë ¥
      if (topic === '/camera/front' && !frontImageDisplayed && image) {
        const img = document.getElementById("frontImage");
        img.src = `data:image/jpg;base64,${image}`;
        img.style.display = 'block';
        frontImageDisplayed = true;
      }

      if (topic === '/camera/back' && !backImageDisplayed && image) {
        const img = document.getElementById("backImage");
        img.src = `data:image/jpg;base64,${image}`;
        img.style.display = 'block';
        backImageDisplayed = true;
      }

    } catch (e) {
      console.error("Parse error:", e);
    }
  });

  let filteredFrontObjects = [];
  let filteredBackObjects = [];

  let frontSeatMap = [];
  let backSeatMap = [];

  function getDistance(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
  }

  function printObjects(topic) {

    if (topic === '/camera/front'){
      console.log(`[${topic}]`, Objects);

      if (Objects) {
        console.log("Detected Front Objects :", Objects);
        Objects.forEach((obj, i) => {
          const [x1, y1, x2, y2] = obj.box;
          const confidence = obj.confidence;

          let found = false;

          for (let i = 0; i < filteredFrontObjects.length; i++) {
            const existing = filteredFrontObjects[i];
            const [exX1, exY1, exX2, exY2] = existing.box;

            const dist1 = getDistance(x1, y1, exX1, exY1);
            const dist2 = getDistance(x2, y2, exX2, exY2);

            if (dist1 <= 20 || dist2 <= 20) {
              found = true;

              // used ë¥¼ ìš°ì„ ì‹œí•˜ëŠ” ì½”ë“œ

              const isNewUsed = obj.label === 'used';
              const isExistingUsed = existing.label === 'used';

              if (isNewUsed && !isExistingUsed) {
                filteredFrontObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, label=used (priority over null)`);
              } else if (!isNewUsed && isExistingUsed) {
                console.log(`(skipped) box=${obj.box}, label=null < existing used`);
              } else if (confidence > existing.confidence) {
                filteredFrontObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, confidence=${obj.confidence}`);
              } else {
                console.log(`(skipped) box=${obj.box}, lower confidence`);
              }

              // confidence ë§Œìœ¼ë¡œ ë¹„êµí•˜ëŠ” ì½”ë“œ

              // if (confidence > existing.confidence) {
              //     filteredObjects[i] = obj;
              //     console.log(`(updated) box=${obj.box}, confidence=${confidence}`);
              // } else {
              //     console.log(`(skipped) box=${obj.box}, lower confidence`);
              // }


              break;
            }

          }

          if (!found) {
            filteredFrontObjects.push(obj);
            console.log(`(new) box=${obj.box}, confidence=${obj.confidence}`);
          }
        });
      }
      // ì •ë ¬: ì•ì¤„ë¶€í„°, ì¢Œì¸¡ë¶€í„°
      // 1. y1 ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë¨¼ì € ì „ì²´ ì •ë ¬
      filteredFrontObjects.sort((a, b) => a.box[1] - b.box[1]);

      console.log("filtered Front Objects: ", filteredFrontObjects)

// 2. y1 ì°¨ì´ë¡œ ê·¸ë£¹í•‘ (ìˆœì„œëŠ” ëª¨ë‹ˆí„°í™”ë©´ì´ ë³´ì´ëŠ” ì •ë°©í–¥ ê¸°ì¤€)
      let rows = [];

// ì²« ë²ˆì§¸ í–‰ (y1 >= 221)
      let row1 = filteredFrontObjects.filter(obj => obj.box[1] > 220);
      if (row1.length > 0) rows.push(row1);

// ë‘ ë²ˆì§¸ í–‰ (141 <= y1 <= 220)
      let row2 = filteredFrontObjects.filter(obj => obj.box[1] > 140 && obj.box[1] <= 220);
      if (row2.length > 0) rows.push(row2);

// ì„¸ ë²ˆì§¸ í–‰ (y1 <= 140)
      let row3 = filteredFrontObjects.filter(obj => obj.box[1] <= 140);
      if (row3.length > 0) rows.push(row3);



// 3. ê° í–‰ì—ì„œ x1 ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
      rows.forEach(row => {
        row.sort((a, b) => a.box[0] - b.box[0]);
      });


      const seatLabels = [
        // Cí–‰
        ['C4', 'C3', 'C2', 'C1'],
        // Bí–‰
        ['B4', 'B3', 'B2', 'B1'],
        // Cí–‰
        ['A4', 'A3', 'A2', 'A1']
      ];

      seatLabels.reverse().forEach((row, i) => {
        seatLabels[i] = row.reverse();
      });


// ê° í–‰ì— ëŒ€í•œ x1 ë²”ìœ„
      const xRangesPerRow = [
        [ [100, 200], [250, 350], [400, 500], [500, 600] ], // A
        [ [100, 200], [300, 400], [500, 600], [600, 700] ], // B
        [ [200, 300], [500, 600], [700, 800], [900, 1000] ]  // C
      ];

      xRangesPerRow.reverse().forEach((row, i) => {
        xRangesPerRow[i] = row.reverse();
      });


// ì¢Œì„ ë§¤í•‘ ê²°ê³¼ ì €ì¥ìš©

      rows.forEach((row, rowIndex) => {
        const rowRanges = xRangesPerRow[rowIndex];
        const rowSeats = Array(4).fill(null); // ì¢Œì„ 4ê°œ

        row.forEach(obj => {
          const x1 = obj.box[0];
          // í•´ë‹¹ í–‰ì˜ ì¢Œì„ ë²”ìœ„ì— ë”°ë¼ ì¢Œì„ ìœ„ì¹˜ ì°¾ê¸°
          for (let i = 0; i < rowRanges.length; i++) {
            const [min, max] = rowRanges[i];
            if (x1 >= min && x1 <= max && !rowSeats[i]) {
              rowSeats[i] = { label: seatLabels[rowIndex][i], ...obj };

              break;
            }
          }
        });

        frontSeatMap.push(rowSeats);
      });

      console.log("frontSeatMap: ", frontSeatMap);

    }


    if (topic === '/camera/back'){
      console.log(`[${topic}]`, Objects);

      if (Objects) {
        console.log("Detected Back Objects:", Objects);
        Objects.forEach((obj, i) => {
          const [x1, y1, x2, y2] = obj.box;
          const confidence = obj.confidence;

          // x1 ê°’ì´ 1200 ì´ìƒì´ë©´ ë¬´ì‹œ
          if (x1 >= 1200) {
            console.log(`(ignored) box=${obj.box}, x1 >= 1200`);
            return;
          }

          let found = false;

          for (let i = 0; i < filteredBackObjects.length; i++) {
            const existing = filteredBackObjects[i];
            const [exX1, exY1, exX2, exY2] = existing.box;

            const dist1 = getDistance(x1, y1, exX1, exY1);
            const dist2 = getDistance(x2, y2, exX2, exY2);

            if (dist1 <= 20 || dist2 <= 20) {
              found = true;

              const isNewUsed = obj.label === 'used';
              const isExistingUsed = existing.label === 'used';

              if (isNewUsed && !isExistingUsed) {
                filteredBackObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, label=used (priority over null)`);
              } else if (!isNewUsed && isExistingUsed) {
                console.log(`(skipped) box=${obj.box}, label=null < existing used`);
              } else if (confidence > existing.confidence) {
                filteredBackObjects[i] = obj;
                console.log(`(updated) box=${obj.box}, confidence=${obj.confidence}`);
              } else {
                console.log(`(skipped) box=${obj.box}, lower confidence`);
              }

              break;
            }

          }

          if (!found) {
            filteredBackObjects.push(obj);
            console.log(`(new) box=${obj.box}, confidence=${obj.confidence}`);
          }
        });
      }
      // ì •ë ¬: ì•ì¤„ë¶€í„°, ì¢Œì¸¡ë¶€í„°
      // 1. y1 ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë¨¼ì € ì „ì²´ ì •ë ¬
      filteredBackObjects.sort((a, b) => a.box[1] - b.box[1]);

      console.log("filtered Back Objects: " , filteredBackObjects)

// 2. y1 ë²”ìœ„ë¡œ ê·¸ë£¹í•‘
      let rows = [];

// ì²« ë²ˆì§¸ í–‰ (200 <= y1 < 270)
      let row1 = filteredBackObjects.filter(obj => obj.box[1] >= 200 && obj.box[1] < 270);
      if (row1.length > 0) rows.push(row1);

// ë‘ ë²ˆì§¸ í–‰ (270 <= y1 < 380)
      let row2 = filteredBackObjects.filter(obj => obj.box[1] >= 270 && obj.box[1] < 380);
      if (row2.length > 0) rows.push(row2);

// ì„¸ ë²ˆì§¸ í–‰ (380 <= y1)
      let row3 = filteredBackObjects.filter(obj => obj.box[1] >= 380);
      if (row3.length > 0) rows.push(row3);

// 3. ê° í–‰ì—ì„œ x1 ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
      rows.forEach(row => {
        row.sort((a, b) => a.box[0] - b.box[0]);
      });

      console.log("rows: ", rows)


      const seatLabels = [
        // Aí–‰
        ['A1', 'A2', 'A3', 'A4'],
        // Bí–‰
        ['B1', 'B2', 'B3', 'B4'],
        // Cí–‰
        ['C1', 'C2', 'C3', 'C4']
      ];

// ê° í–‰ì— ëŒ€í•œ x1 ë²”ìœ„
      const xRangesPerRow = [
        [ [0, 650], [650, 800], [800, 950], [950, 1200] ], // A
        [ [0, 400], [400, 700], [700, 900], [900, 1200] ], // B
        [ [0, 200], [200, 500], [500, 850], [850, 1200] ]  // C
      ];

// ì¢Œì„ ë§¤í•‘ ê²°ê³¼ ì €ì¥ìš©

      rows.forEach((row, rowIndex) => {
        const rowRanges = xRangesPerRow[rowIndex];
        const rowSeats = Array(4).fill(null); // ì¢Œì„ 4ê°œ

        row.forEach(obj => {
          const x1 = obj.box[0];
          // í•´ë‹¹ í–‰ì˜ ì¢Œì„ ë²”ìœ„ì— ë”°ë¼ ì¢Œì„ ìœ„ì¹˜ ì°¾ê¸°
          for (let i = 0; i < rowRanges.length; i++) {
            const [min, max] = rowRanges[i];
            if (x1 >= min && x1 <= max && !rowSeats[i]) {
              rowSeats[i] = { label: seatLabels[rowIndex][i], ...obj };
              break;
            }
          }
        });

        backSeatMap.push(rowSeats);
      });

      console.log("backSeatMap:", backSeatMap);

    }

    function getLabelPriority(label) {
      if (label === 'used') return 2;
      if (label) return 1; // ë¹„ì‹ë³„(labelì€ ì¡´ì¬í•˜ë˜ usedê°€ ì•„ë‹Œ ê²½ìš°)
      return 0; // null ë˜ëŠ” undefined
    }



// í˜¸ì¶œ
    setupSeats();

  }

  function mergeSeatMaps(frontSeatMap, backSeatMap) {
    const mergedSeatMap = [];

    for (let row = 0; row < 3; row++) {
      const mergedRow = [];

      for (let col = 0; col < 4; col++) {
        const frontSeat = frontSeatMap?.[row]?.[col] || null;
        const backSeat = backSeatMap?.[row]?.[col] || null;

        if (frontSeat && !backSeat) {
          mergedRow.push(frontSeat);
        } else if (!frontSeat && backSeat) {
          mergedRow.push(backSeat);
        } else if (frontSeat && backSeat) {
          const frontPriority = getLabelPriority(frontSeat.label);
          const backPriority = getLabelPriority(backSeat.label);

          if (frontPriority > backPriority) {
            mergedRow.push(frontSeat);
          } else if (backPriority > frontPriority) {
            mergedRow.push(backSeat);
          } else {
            // ê°™ì€ ìš°ì„ ìˆœìœ„ë©´ confidence ë¹„êµ
            mergedRow.push(
                    frontSeat.confidence >= backSeat.confidence ? frontSeat : backSeat
            );
          }
        } else {
          mergedRow.push(null);
        }
      }

      mergedSeatMap.push(mergedRow);
    }

    return mergedSeatMap;
  }


  async function setupSeats() {
    const mergeSeatMap = mergeSeatMaps(frontSeatMap, backSeatMap);
    console.log("Merged Seat Map:", mergeSeatMap);

    try {
      const res = await fetch('/reserve');
      const data = await res.json();
      console.log("âœ… DBì—ì„œ ê°€ì ¸ì˜¨ ì˜ˆì•½ ì¢Œì„ ëª©ë¡:", data);

      // ì˜ˆì•½ ì¢Œì„ì„ mergeSeatMapì— ë°˜ì˜
      data.forEach(seat => {
        const seatName = seat.seatName;
        const rowChar = seatName[0]; // A, B, C...
        const colNum = parseInt(seatName.slice(1), 10); // 1, 2, 3...

        const rowIndex = rowChar.charCodeAt(0) - 'A'.charCodeAt(0); // 'A' -> 0
        const colIndex = colNum - 1;

        if (mergeSeatMap[rowIndex] && mergeSeatMap[rowIndex][colIndex]) {
          mergeSeatMap[rowIndex][colIndex].label = seat.approved ? 'used' : 'reserved';
        }
      });

      const finalSeatMap = mergeSeatMap;
      console.log("ğŸ§© ìµœì¢…ì‹œíŠ¸ë§µ", finalSeatMap);

      const seatLabels = [
        ['A1', 'A2', 'A3', 'A4'],
        ['B1', 'B2', 'B3', 'B4'],
        ['C1', 'C2', 'C3', 'C4']
      ];

      for (let row = 0; row < seatLabels.length; row++) {
        for (let col = 0; col < seatLabels[row].length; col++) {
          const seatId = `seat-${row}-${col}`;
          const seatDiv = document.getElementById(seatId);
          const seatInfo = finalSeatMap[row][col];

          seatDiv.classList.remove('empty', 'used', 'unknown', 'reserved');

          if (!seatInfo) {
            seatDiv.classList.add('unknown');
          } else if (seatInfo.label === 'used') {
            seatDiv.classList.add('used');
          } else if (seatInfo.label === 'null') {
            seatDiv.classList.add('empty');
          } else if (seatInfo.label === 'reserved') {
            seatDiv.classList.add('reserved');
          } else {
            seatDiv.classList.add('unknown');
          }
        }
      }

    } catch (err) {
      console.error("âŒ ì¢Œì„ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", err);
    }
  }

  document.querySelectorAll('.seat').forEach(seat => {
    seat.addEventListener('click', () => {
      const seatName = seat.textContent; // í´ë¦­í•œ ì¢Œì„ ì´ë¦„
      const username = /*[[${Email}]]*/ 'guest'; // ì‹¤ì œë¡œëŠ” ì„œë²„ì—ì„œ ì „ë‹¬ë°›ì€ ì‚¬ìš©ì ì´ë©”ì¼

      console.log("username:", username);

      // 'empty' í´ë˜ìŠ¤ê°€ ìˆì„ ë•Œë§Œ í´ë¦­ í—ˆìš©
      if (seat.classList.contains('empty')) {
        // ë¨¼ì € ì‚¬ìš©ìì˜ ì˜ˆì•½ ì—¬ë¶€ í™•ì¸
        fetch(`/reserved-seat/${username}`)
                .then(res => {
                  if (!res.ok) {
                    throw new Error('ì„œë²„ ì˜¤ë¥˜: ' + res.status);
                  }
                  return res.text(); // ë¨¼ì € text()ë¡œ ë°›ì•„ì„œ í™•ì¸ (null ì²˜ë¦¬ë¥¼ ìœ„í•¨)
                })
                .then(text => {
                  const data = text ? JSON.parse(text) : null;
                  if (data) {
                    // ì´ë¯¸ ì˜ˆì•½ëœ ì¢Œì„ì´ ìˆëŠ” ê²½ìš°

                    const currentSeatName = data.seatName; // ì˜ˆì•½ëœ ì¢Œì„ ì´ë¦„
                    const approved = data.approved; // ìŠ¹ì¸ ì—¬ë¶€

                    if (approved) {
                      alert("ìŠ¹ì¸ëœ ì¢Œì„ì€ ì˜ˆì•½ ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.");
                      return;
                    }
                    const userMessage = `${username}ë‹˜ì€ ì´ë¯¸ ${currentSeatName} ì¢Œì„ì„ ì˜ˆì•½í•˜ì…¨ìŠµë‹ˆë‹¤. ì¢Œì„ì„ ë³€ê²½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;

                    if (confirm(userMessage)) {
                      // ê¸°ì¡´ ì¢Œì„ì— ëŒ€í•´ 'reserved' í´ë˜ìŠ¤ë¥¼ 'empty'ë¡œ ë³€ê²½
                      const prevRow = currentSeatName.charCodeAt(0) - 'A'.charCodeAt(0); // 'A' -> 0
                      const prevCol = parseInt(currentSeatName.slice(1)) - 1; // 1, 2, 3... -> 0, 1, 2...
                      const prevSeatDiv = document.getElementById(`seat-${prevRow}-${prevCol}`);
                      prevSeatDiv.classList.remove('reserved');
                      prevSeatDiv.classList.add('empty');

                      // ì¢Œì„ ë³€ê²½ì„ ìœ„í•œ ìš”ì²­
                      fetch('/update-reservation', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                          seatName: seatName,
                          reservedBy: username
                        })
                      })
                              .then(res => res.json())  // ì„œë²„ ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±
                              .then(data => {
                                if (data.success) {
                                  alert(data.message); // "ì¢Œì„ ë³€ê²½ ì„±ê³µ!" ë©”ì‹œì§€ ì¶œë ¥
                                  seat.classList.remove('empty');
                                  seat.classList.add('reserved');
                                  updateReservationInfo(username);
                                } else {
                                  alert("ì¢Œì„ ë³€ê²½ ì‹¤íŒ¨: " + data.message); // "ì¢Œì„ ë³€ê²½ ì‹¤íŒ¨" ë©”ì‹œì§€ ì¶œë ¥
                                }
                              })
                              .catch(error => {
                                alert("ì„œë²„ì™€ì˜ í†µì‹ ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                                console.error(error);
                              });

                    }
                  } else {
                    // ì˜ˆì•½ëœ ì¢Œì„ì´ ì—†ë‹¤ë©´ ìƒˆë¡œìš´ ì¢Œì„ ì˜ˆì•½
                    if (confirm(`${seatName} ì¢Œì„ì„ ì˜ˆì•½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                      // ìƒˆë¡œìš´ ì˜ˆì•½ì„ ìœ„í•œ ìš”ì²­
                      fetch('/reserve', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ seatName, username })
                      })
                              .then(res => res.json())
                              .then(data => {
                                if (data.success) {
                                  alert("ì˜ˆì•½ ì„±ê³µ!");
                                  seat.classList.remove('empty');
                                  seat.classList.add('reserved');
                                  updateReservationInfo(username);
                                } else {
                                  alert("ì˜ˆì•½ ì‹¤íŒ¨: " + data.message);
                                }
                              });
                    }
                  }
                })
                .catch(error => {
                  console.error("ì˜ˆì•½ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ", error);
                });
      }
    });
  });


  let currentReservation = null; // ì „ì—­ ë³€ìˆ˜ë¡œ í˜„ì¬ ì˜ˆì•½ ì •ë³´ ì €ì¥

  function updateReservationInfo(username) {
    fetch(`/reserved-seat/${username}`)
            .then(res => {
              if (!res.ok) throw new Error('ì„œë²„ ì˜¤ë¥˜: ' + res.status);
              return res.text();
            })
            .then(text => {
              const data = text ? JSON.parse(text) : null;

              const reservedSeatElement = document.getElementById("reserved-seat");
              const reservationTimeElement = document.getElementById("reservation-time");
              const cancelButton = document.getElementById("cancel-reservation");

              if (data && data.seatName && data.updateTime) {
                currentReservation = {
                  seatName: data.seatName,
                  reservedBy: username,
                  approved: data.approved
                };

                const date = new Date(data.updateTime);
                const pad = n => n.toString().padStart(2, '0');
                const formatted = `${date.getFullYear()}ë…„ ${pad(date.getMonth() + 1)}ì›” ${pad(date.getDate())}ì¼ `
                        + `${pad(date.getHours())}ì‹œ ${pad(date.getMinutes())}ë¶„ ${pad(date.getSeconds())}ì´ˆ`;

                reservedSeatElement.textContent = `ì˜ˆì•½ëœ ì¢Œì„: ${data.seatName}`;
                reservationTimeElement.textContent = `ì˜ˆì•½ ë“±ë¡ ì‹œê°: ${formatted}`;
                cancelButton.style.display = 'inline-block';
              } else {
                currentReservation = null;
                reservedSeatElement.textContent = "ì˜ˆì•½ëœ ì¢Œì„ì´ ì—†ìŠµë‹ˆë‹¤.";
                reservationTimeElement.textContent = "";
                cancelButton.style.display = 'none';
              }
            })
            .catch(error => {
              console.error("ì„œë²„ì—ì„œ ì˜ˆì•½ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:", error);
            });
  }

  function cancelReservation() {
    const cancelButton = document.getElementById("cancel-reservation");

    cancelButton.addEventListener('click', () => {
      if (!currentReservation) return;

      const { seatName, reservedBy, approved } = currentReservation;

      if (approved) {
        alert("ìŠ¹ì¸ëœ ì¢Œì„ì€ ì˜ˆì•½ ì·¨ì†Œê°€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.");
        return;
      }

      if (confirm(`ì •ë§ ${seatName} ì¢Œì„ ì˜ˆì•½ì„ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
        fetch('/cancel-reservation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ seatName, reservedBy })
        })
                .then(res => res.json())
                .then(response => {
                  if (response.success) {
                    alert("ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
                    document.getElementById("reserved-seat").textContent = "ì˜ˆì•½ëœ ì¢Œì„ì´ ì—†ìŠµë‹ˆë‹¤.";
                    document.getElementById("reservation-time").textContent = "";
                    cancelButton.style.display = 'none';
                    currentReservation = null;
                    // í™”ë©´ì´ ì œëŒ€ë¡œ ê°±ì‹ ë  ìˆ˜ ìˆë„ë¡ ë”œë ˆì´ ì¶”ê°€
                    setTimeout(() => setupSeats(), 500); // 0.5ì´ˆ ë’¤ì— setupSeats ì‹¤í–‰
                  } else {
                    alert("ì˜ˆì•½ ì·¨ì†Œ ì‹¤íŒ¨: " + response.message);
                  }
                })
                .catch(error => {
                  alert("ì„œë²„ì™€ì˜ í†µì‹ ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                  console.error(error);
                });
      }
    });
  }


  document.addEventListener('DOMContentLoaded', function () {
    const username = /*[[${Email}]]*/ 'guest';
    cancelReservation(); // ìµœì´ˆ 1íšŒë§Œ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    updateReservationInfo(username);
  });





</script>


</body>
</html>
